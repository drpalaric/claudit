# Check 3: Architecture and Domain Context

Missing architecture context causes locally-correct but globally-inconsistent changes.

1. **Codebase map**: Does the file include a directory overview explaining the purpose of directories? Flag as HIGH if absent. Check completeness against the reconciliation output's "Directory Counts" section: every depth-1 and depth-2 directory from the reconciliation must appear in the codebase map. Flag as MEDIUM if the map exists but is missing directories. For depth-3 directories, include individually unless many siblings follow a pattern (use `{pattern}/` placeholder). Example:
   ```
   cmd/          — Entrypoints (one per binary)
   internal/
     api/        — HTTP handlers, one file per resource
     service/    — Business logic, no direct DB access
     store/      — All database queries
   migrations/   — SQL migration files, sequential, immutable once merged
   infra/        — Terraform, do not modify without DevOps review
   ```

2. **Domain vocabulary**: Does the file name the key domain entities and concepts specific to this project? Flag as MEDIUM if absent. Example: *"Core entities: `Account` (a business), `Member` (a user within an Account), `Workspace` (a project container within an Account). Do not use 'user' or 'org' — those are not our terms."*

3. **Entry points**: Are the main execution entry points identified? (e.g., CLI command, HTTP handler, serverless function, cron entrypoint, event consumer).

4. **Active design patterns**: Are the architectural patterns in use named? (Repository pattern, CQRS, event sourcing, hexagonal architecture, etc.) Flag as MEDIUM if absent. Example: *"We use the Repository pattern. Services call repos; repos call the database. Services never issue SQL directly."*

5. **Third-party integrations**: Are major external dependencies named upfront? Example: *"Auth: Auth0. Payments: Stripe. Email: Postmark. Observability: Datadog. Do not suggest alternatives — these are contractually in place."*

6. **No-go zones**: Are generated, vendor, legacy, or read-only directories identified? Flag as HIGH if any generated/vendor directories exist and are not called out. Example: *"`src/generated/` is auto-generated by the ORM. Never edit it directly. `vendor/` is vendored dependencies. Do not modify."*

7. **Monorepo structure**: If the repository is a monorepo, does the file explain the workspace layout and whether package-level `CLAUDE.md` files exist? Claude needs to know which package's commands to run and where boundaries are. A monorepo root `CLAUDE.md` should describe the workspace tool and point to per-package files.

8. **Reference implementations**: When the CLAUDE.md says "follow the existing pattern" or "match the style of other modules," does it name a specific file or directory as the canonical example? Vague references force Claude to guess which file to use as a template — and it often picks the wrong one. Flag as MEDIUM if pattern-following instructions don't point to a concrete reference. Example: *"New API handlers should follow the structure in `internal/api/clusters.go` — it is the canonical example for request validation, service calls, and error responses."*
