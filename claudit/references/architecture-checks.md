# Check 3: Architecture and Domain Context

A CLAUDE.md without architecture context forces Claude to rediscover structure every session, make incorrect assumptions about design patterns, and introduce changes that are locally correct but globally inconsistent.

The most common failure mode is a CLAUDE.md that tells Claude *how to behave* but not *what it's working on*. Both are required.

1. **Codebase map**: Does the file include a brief directory overview explaining the purpose of major directories? Without this, Claude spends tokens on filesystem exploration that should be spent on the task. Flag as HIGH if absent. Example:
   ```
   cmd/          — Entrypoints (one per binary)
   internal/
     api/        — HTTP handlers, one file per resource
     service/    — Business logic, no direct DB access
     store/      — All database queries
   migrations/   — SQL migration files, sequential, immutable once merged
   infra/        — Terraform, do not modify without DevOps review
   ```

2. **Domain vocabulary**: Does the file name the key domain entities and concepts specific to this project? Without this, Claude uses generic names that don't match the codebase's conventions, or conflates entities with similar names. Flag as MEDIUM if absent. Example: *"Core entities: `Account` (a business), `Member` (a user within an Account), `Workspace` (a project container within an Account). Do not use 'user' or 'org' — those are not our terms."*

3. **Entry points**: Are the main execution entry points identified? (e.g., CLI command, HTTP handler, serverless function, cron entrypoint, event consumer). Claude defaults to grepping for `main()` or similar and guessing — explicit entry points prevent mis-rooted changes.

4. **Active design patterns**: Are the architectural patterns in use named? (Repository pattern, CQRS, event sourcing, hexagonal architecture, etc.) Without this, Claude will introduce conflicting patterns as "improvements." Flag as MEDIUM if absent. Example: *"We use the Repository pattern. Services call repos; repos call the database. Services never issue SQL directly."*

5. **Third-party integrations**: Are major external dependencies named upfront? Prevents Claude from suggesting alternatives that conflict with existing vendor contracts or integrations. Example: *"Auth: Auth0. Payments: Stripe. Email: Postmark. Observability: Datadog. Do not suggest alternatives — these are contractually in place."*

6. **No-go zones**: Are generated, vendor, legacy, or read-only directories identified? Without this, Claude may modify generated files (losing changes on next generation) or attempt to refactor locked codebases. Flag as HIGH if any generated/vendor directories exist and are not called out. Example: *"`src/generated/` is auto-generated by the ORM. Never edit it directly. `vendor/` is vendored dependencies. Do not modify."*

7. **Monorepo structure**: If the repository is a monorepo, does the file explain the workspace layout and whether package-level `CLAUDE.md` files exist? Claude needs to know which package's commands to run and where boundaries are. A monorepo root `CLAUDE.md` should describe the workspace tool and point to per-package files.

8. **Reference implementations**: When the CLAUDE.md says "follow the existing pattern" or "match the style of other modules," does it name a specific file or directory as the canonical example? Vague references force Claude to guess which file to use as a template — and it often picks the wrong one. Flag as MEDIUM if pattern-following instructions don't point to a concrete reference. Example: *"New API handlers should follow the structure in `internal/api/clusters.go` — it is the canonical example for request validation, service calls, and error responses."*
